#!/usr/bin/env python

# -----------------------------------------------------------------------------
# Copyright (c) 2014--, The American Gut Development Team.
#
# Distributed under the terms of the BSD 3-clause License.
#
# The full license is in the file LICENSE, distributed with this software.
# -----------------------------------------------------------------------------

from os import listdir
from os.path import abspath, join, dirname, split
from glob import glob

from psycopg2 import connect, OperationalError
from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT
from natsort import natsorted
import click

from amgut import db_conn, AG_DATA_ACCESS
from amgut.lib.config_manager import AMGUT_CONFIG
from amgut.lib.util import LAYOUT_FP, INITIALIZE_FP, POPULATE_FP, PATCHES_DIR
from amgut.lib.data_access.sql_connection import SQLConnectionHandler


def _check_db_exists(db, cursor):
    r"""Check if the database db exists on the postgres server

    Parameters
    ----------
    db : str
        The database name
    cursor : psycopg2.cursor
        The cursor connected to the server
    """
    cursor.execute('SELECT datname FROM pg_database')
    # It's a list of tuple, so just create the tuple to check if exists
    return (db,) in cursor.fetchall()


@click.group()
def cli():
    pass


@cli.group()
def env():
    pass


@cli.command()
@click.argument('mode', required=True, 
                type=click.Choice(['maintenance', 'production']))
@click.option('--message', type=str, 
              default='The site is down for maintenance')
def mode(mode, message):
    """Enable maintenance or production mode.

    In maintenance mode, active connections will remain active during
    maintenance mode, however logins will be disabled. The 'message' will be
    displayed on the banner for everyone who is logged in, and those going to
    the site to login. Ideally, the message is phrased to indicate that "those
    logged in can continue until ... time."

    In production mode, the banner message is not displayed and logins are
    enabled.
    """
    from amgut import r_server

    if mode == 'maintenance':
        r_server.set('maintenance', message)
        click.echo("Warning, going into maintenance mode. Logins disabled!")
    elif mode == 'production':
        r_server.delete('maintenance')
        click.echo("Warning, going into production mode. Logins enabled!")


@env.command()
@click.argument('db', type=click.Choice(['test', 'production']))
def make(db):
    if db == 'test':
        _create_database()
        _make_settings_table()
        _build_and_initialize()
        _patch()
        _populate_test_db()
        print("Test environment successfully created")

    if db == 'production':
        _create_database()
        _make_settings_table()
        _build_and_initialize()
        _patch()
        print("Production environment successfully created")


@env.command()
def clean_test():
    db_conn._connection.close()
    AG_DATA_ACCESS.connection.close()

    conn = connect(user=AMGUT_CONFIG.user, password=AMGUT_CONFIG.password,
                   host=AMGUT_CONFIG.host, port=AMGUT_CONFIG.port,
                   database=AMGUT_CONFIG.database)

    cur = conn.cursor()

    cur.execute('select test_environment from settings')
    is_test_db = cur.fetchone()[0].lower()
    cur.close()
    conn.close()

    conn = connect(user=AMGUT_CONFIG.user, password=AMGUT_CONFIG.password,
                   host=AMGUT_CONFIG.host, port=AMGUT_CONFIG.port)
    cur = conn.cursor()

    conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)

    if is_test_db == 'false':
        raise OperationalError("The settings table indicates this is not "
                               "a test database; aborting.")
    else:
        cur.execute('drop database {}'.format(AMGUT_CONFIG.database))
        print("Database %s dropped" % AMGUT_CONFIG.database)
        cur.execute('drop role ag_wwwuser')
        print("role ag_wwwuser dropped")
        cur.close()
        conn.close()


@env.command()
def patch():
    """Patches the database schema based on the SETTINGS table

    Pulls the current patch from the settings table and applies all subsequent
    patches found in the patches directory.
    """
    _patch()


def _create_database():
    # Connect to the postgres server
    try:
        conn = connect(user=AMGUT_CONFIG.user, password=AMGUT_CONFIG.password,
                       host=AMGUT_CONFIG.host, port=AMGUT_CONFIG.port)
    except OperationalError as e:
        raise OperationalError("Cannot connect to the server, error is %s" %
                               str(e))

    # Set the isolation level to AUTOCOMMIT so we can execute a create database
    # sql query
    conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)
    # Get the cursor
    cur = conn.cursor()
    # Check that the database does not already exists
    if _check_db_exists(AMGUT_CONFIG.database, cur):
        raise ValueError("Database '%s' already present on the system"
                         % AMGUT_CONFIG.database)
    # Create the database
    print("Creating database")
    cur.execute('CREATE DATABASE %s' % AMGUT_CONFIG.database)
    cur.close()
    conn.close()


def _build_and_initialize():
    conn = connect(user=AMGUT_CONFIG.user, password=AMGUT_CONFIG.password,
                   host=AMGUT_CONFIG.host, port=AMGUT_CONFIG.port,
                   database=AMGUT_CONFIG.database)
    curr = conn.cursor()

    # create the schema and set a search path
    curr.execute('create schema ag')
    curr.execute('set search_path to ag, public')

    print("Inserting procedures")
    procedures_dirpath = join(dirname(dirname(abspath(__file__))), "amgut",
                              "lib", "data_access", "procedures")
    for procedure_f in glob(join(procedures_dirpath, '*.sql')):
        with open(join(procedures_dirpath, procedure_f)) as f:
            curr.execute(f.read())

    print("Building SQL layout")
    with open(LAYOUT_FP) as f:
        # We have to skip the "create schema" line here
        curr.execute('\n'.join(f.readlines()[1:]))

    with open(INITIALIZE_FP) as f:
        curr.execute(f.read())

    print('Granting privileges')

    # create 
    curr.execute('create user "ag_wwwuser"')
    curr.execute('grant usage on schema public, ag to "ag_wwwuser"') 
    curr.execute('grant connect on database %s to "ag_wwwuser"' %
                 AMGUT_CONFIG.database) 
    curr.execute('GRANT INSERT, UPDATE, DELETE, SELECT ON ALL TABLES IN SCHEMA'
                 ' public, ag TO "ag_wwwuser";')
    curr.execute('GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public, ag TO '
                 '"ag_wwwuser";')
    conn.commit()


def _make_settings_table():
    conn = SQLConnectionHandler()
    settings = AMGUT_CONFIG.get_settings()

    columns = [' '.join([setting[0], 'varchar']) for setting in settings]
    column_names = [setting[0] for setting in settings]


    num_values = len(settings)
    sql = "insert into settings ({}) values ({})".format(
          ', '.join(column_names), ', '.join(['%s']*num_values))
    args = [str(setting[1]) for setting in settings]

    with conn.get_postgres_cursor() as cur:
        create_sql = "create table settings ({}, current_patch varchar not null default 'unpatched')"
        create_sql = create_sql.format(', '.join(columns))

        cur.execute(create_sql)
        cur.execute(sql, args)


def _populate_test_db():
    print("Populating the test database")
    conn = SQLConnectionHandler()
    with open(POPULATE_FP) as f:
        conn.execute(f.read())


def _patch(patches_dir=PATCHES_DIR):
    """Patches the database schema based on the SETTINGS table

    Pulls the current patch from the settings table and applies all subsequent
    patches found in the patches directory.
    """
    print("Patching the database...")
    conn = SQLConnectionHandler()

    current_patch = conn.execute_fetchone(
        "SELECT current_patch FROM settings")[0]
    current_patch_fp = join(patches_dir, current_patch)

    sql_glob = join(patches_dir, '*.sql')
    patch_files = natsorted(glob(sql_glob))

    if current_patch == 'unpatched':
        next_patch_index = 0
    elif current_patch_fp not in patch_files:
        raise RuntimeError("Cannot find patch file %s" % current_patch)
    else:
        next_patch_index = patch_files.index(current_patch_fp) + 1

    patch_update_sql = "UPDATE settings SET current_patch = %s"

    for patch_fp in patch_files[next_patch_index:]:
        patch_filename = split(patch_fp)[-1]
        with conn.get_postgres_cursor() as cur:
            with open(patch_fp, 'U') as patch_file:
                print('\tApplying patch %s...' % patch_filename)
                cur.execute(patch_file.read())
                cur.execute(patch_update_sql, [patch_filename])

        conn._connection.commit()


if __name__ == '__main__':
    cli()
